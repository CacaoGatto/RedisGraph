/*
* Copyright 2018-2020 Redis Labs Ltd. and Contributors
*
* This file is available under the Redis Labs Source Available License Agreement
*/

#include "cmd_bulk_insert.h"
#include "cmd_context.h"
#include "../util/rmalloc.h"
#include "../util/thpool/pools.h"
#include "../bulk_insert/bulk_insert.h"

// bulk-insert context object
typedef struct {
	int argc;                      // number of arguments
	RedisModuleString **argv;      // arguments
	RedisModuleBlockedClient *bc;  // blocked client
} BulkCtx;

// bulk-insert process a batch of node/edge creation generated by the
// bulk-insert utility
static void _MGraph_BulkInsert(void *args) {
	// unpack arguments
	BulkCtx *bulk_ctx = (BulkCtx*)args;
	int argc = bulk_ctx->argc;
	RedisModuleString **argv = bulk_ctx->argv;
	RedisModuleBlockedClient *bc = bulk_ctx->bc;
	RedisModuleCtx *ctx = RedisModule_GetThreadSafeContext(bc);
	RedisModuleKey *key;
	long long node_count;  // number of declared nodes
	long long edge_count;  // number of declared edges
	GraphContext *gc = NULL;

	argv += 1; // skip "GRAPH.BULK"
	RedisModuleString *rs_graph_name = *argv++;
	const char *graphname = RedisModule_StringPtrLen(rs_graph_name, NULL);
	argc -= 2; // skip "GRAPH.BULK [GRAPHNAME]"

	// TODO: consider introducing a function to handle BEGIN
	if(!strcmp(RedisModule_StringPtrLen(*argv, 0), "BEGIN")) {
		argv ++;
		argc --;
		// verify that graph does not already exist
		// TODO: I believe GIL must be acquired before opening a key
		key = RedisModule_OpenKey(ctx, rs_graph_name, REDISMODULE_READ);
		RedisModule_CloseKey(key);
		if(key) {
			// TODO: introduce an error in errors.h
			char *err;
			asprintf(&err, "Graph with name '%s' cannot be created, as Redis key '%s' already exists.",
					 graphname, graphname);
			RedisModule_ReplyWithError(ctx, err);
			free(err);
			goto cleanup;
		}
	}

	// read the user-provided counts for nodes and edges in the current query
	if(RedisModule_StringToLongLong(*argv++, &node_count) != REDISMODULE_OK) {
		RedisModule_ReplyWithError(ctx, "Error parsing node count.");
		goto cleanup;
	}

	if(RedisModule_StringToLongLong(*argv++, &edge_count) != REDISMODULE_OK) {
		RedisModule_ReplyWithError(ctx, "Error parsing relation count.");
		goto cleanup;
	}

	argc -= 2; // already read node count and edge count

	// TODO: move right after "BEGIN" handeling?
	gc = GraphContext_Retrieve(ctx, rs_graph_name, false, true);

	// TODO: 'rc' ?
	int rc = BulkInsert(ctx, gc, argv, argc, node_count, edge_count);

	if(rc == BULK_FAIL) {
		// if insertion failed, clean up keyspace and free added entities
		// TODO: I think we must acquire GIL before accessing a key
		key = RedisModule_OpenKey(ctx, rs_graph_name, REDISMODULE_WRITE);
		RedisModule_DeleteKey(key);
		gc = NULL;
		goto cleanup;
	}

	// successful bulk commands should always modify slaves
	RedisModule_ReplicateVerbatim(ctx);

	// replay to caller
	char reply[1024];
	int len = snprintf(reply, 1024, "%llu nodes created, %llu edges created",
				   node_count, edge_count);
	RedisModule_ReplyWithStringBuffer(ctx, reply, len);

cleanup:
	// restore argc and argv
	argc = bulk_ctx->argc;
	argv = bulk_ctx->argv;

	// free retained strings
	for(int i = 0; i < argc; i++) RedisModule_FreeString(ctx, argv[i]);

	if(gc) GraphContext_Release(gc);
	rm_free(bulk_ctx);
}

int MGraph_BulkInsert(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
	if(argc < 3) return RedisModule_WrongArity(ctx);

	// retain strings
	for(int i = 0; i < argc; i++) RedisModule_RetainString(ctx, argv[i]);

	// create bulk insert context object
	BulkCtx *bulk_ctx = rm_malloc(sizeof(BulkCtx));
	bulk_ctx->bc = RedisModule_BlockClient(ctx, NULL, NULL, NULL, 0);
	bulk_ctx->argv = argv;
	bulk_ctx->argc = argc;

	// invoke bulk-insert on a writer worker thread
	ThreadPools_AddWorkWriter(_MGraph_BulkInsert, bulk_ctx);

	return REDISMODULE_OK;
}

